<!DOCTYPE html>
<html>
	<head>
		<title>Q ⟩ Gate</title>
		<meta charset="utf-8">
		<meta name="viewport"             content="width=device-width,initial-scale=1.0">
		<meta name="description"          content="Quantum computing in your browser.">
		<meta name="copyright"            content="Stewart Smith 2019–2020">
		<meta name="keywords"             content="
			Q, Q.js, Q-js, Qjs, quantum JavaScript,
			quantum, quantum physics, quantum mechanics, superposition,
			quantum computer, quantum computer programming, quantum computing, QC, 
			quantum simulator, quantum computer simulator, 
			qubit, qbit, gate, Hadamard, Bloch, Bloch Sphere,
			Web, Web site, website, Web browser, browser, HTML, HTML5, JavaScript, ES6, CSS,
			Chrome, Firefox, Safari, Opera, Brave, Edge, WebKit, Blink, Gecko, Mozilla,
			Stewart Smith, Stewart, Stew, Stuart, Steven, Steve, Stewdio, stewartsmith, stew_rtsmith, @stew_rtsmith,
			Moar, Moar Technologies Corp, MTC,
			Google, IBM, Microsoft, Amazon, NASA, DWave, D-Wave,
			Quil, OpenQASM,
				ProjectQ, Qiskit, 
				Quantum Development Kit, Cirq, Strawberry Fields, t|ket>,
				QCL, Quantum pseudocode, Q#, Q|SI>, Q language, qGCL, QFC, QML, LIQUi|>, Quipper,
			Stanford CS 269 Q: Quantum Computer Programming">
		
		<meta name="twitter:card"         content="summary_large_image">
		<meta name="twitter:site"         content="@stew_rtsmith">
		<meta name="twitter:creator"      content="@stew_rtsmith">
		<meta name="twitter:title"        content="Q ⟩ Gate">
		<meta name="twitter:description"  content="Quantum computing in your browser.">
		<meta name="twitter:image"        content="https://quantumjavascript.app/assets/Q-website-preview.jpg">
		
		<meta property="og:type"          content="website">
		<meta property="og:title"         content="Q ⟩ Gate">
		<meta property="og:description"   content="Quantum computing in your browser.">
		<meta property="og:image"         content="https://quantumjavascript.app/assets/Q-website-preview.jpg">
		<meta property="og:url"           content="https://quantumjavascript.app/Gate.html">
		
		<link rel="canonical" href="https://quantumjavascript.app/Gate.html">
		<link href="assets/Q-favicon-064.png" rel="icon" type="image/png">
		<link href="assets/Q-favicon-144.png" rel="apple-touch-icon">
		
		<link rel="stylesheet" href="packages/quantum-js-vis/Q.css">
		<link rel="stylesheet" href="packages/quantum-js-vis/Q-Circuit-Editor.css">
		<link rel="stylesheet" href="assets/documentation.css">

		<script src="https://www.googletagmanager.com/gtag/js" async></script>
		<script src="assets/ga.js"></script>
		<script src="build/bundle.js"></script>
		<script src="assets/navigation.js"></script>
		
	</head>
	<body>
		<main class="api">
			<p>
				Source code:
				<a href="https://github.com/stewdio/q.js/blob/master/source/Q-Gate.js?ts=4" target="_blank">
					<code>Q-Gate.js</code>
				</a>
			</p>
			<hr>
			<h3>Gates to walk through</h3>
			<p>
				A quantum computer is just a collection of 
				<a href="Q-Qubit.html">qubits</a>.
				These qubits hold values like 
				<code>1</code>, <code>0</code>, or some value inbetween.
				A quantum computer 
				is able to calculate things
				by changing the value of its qubits over time.
				We tell the computer exactly how it should change 
				the value of a qubit
				by instructing it to 
				“walk through” a series of 
				<a href="https://en.wikipedia.org/wiki/Quantum_logic_gate" target="_blank">quantum gates</a>.
				As the qubit 
				<a href="https://en.wikipedia.org/wiki/The_Gates" target="_blank">“walks through” each gate</a>
				its value is changed based on the type of gate
				it is passing through.
			</p>
			<p>
				Contrary to what pop-science might tell you,
				there is nothing random or unpredictable
				about this process.
				Mathematically, a
				<a href="Q-Qubit.html">qubit</a> is just a 
				<a href="Q-Matrix.html">matrix</a>.
				Similarly, a quantum gate is also just a <a href="Q-Matrix.html">matrix</a>.
				To apply a gate to a qubit
				is to 
				<a href="Q-Matrix.html#.prototype.multiply">multiply these matrices together</a>.
				To demonstrate this,
				let’s begin with a 
				<a href="Q-Qubit.html#.HORIZONTAL">“Horizontal” 
				qubit</a>—commonly thought of as 
				representing “off.”
				It has the following matrix form:
			</p>
			<div class="center">				
				<div class="matrix qubit">
					<div class="matrix-bracket-left"></div>
					<div class="matrix-bracket-right"></div>
					<table>
						<tr><td>1</td></tr>
						<tr><td>0</td></tr>
					</table>
				</div>
				<a href="Q-Qubit.html#.HORIZONTAL">Horizontal qubit</a>
			</div>
			<p>
				We would like to flip the value of this qubit
				from “off” to “on.”
				The result will be a
				<a href="Q-Qubit.html#.VERTICAL">“Vertical” 
				qubit</a>
				with the following matrix form:
			</p>
			<div class="center">
				<div class="matrix qubit">
					<div class="matrix-bracket-left"></div>
					<div class="matrix-bracket-right"></div>
					<table>
						<tr><td>0</td></tr>
						<tr><td>1</td></tr>
					</table>
				</div>
				<a href="Q-Qubit.html#.VERTICAL">Vertical qubit</a>
			</div>
			<p>
				In order to achieve this
				we must apply a <a href="#.PAULI_X">Pauli&nbsp;X gate</a>
				to our  
				<a href="Q-Qubit.html#.HORIZONTAL">Horizontal qubit</a>.
				Pauli&nbsp;X gates have the effect of “flipping” the value of a qubit.
				They are often thought of 
				as the quantum equivalent of
				a <a href="https://en.wikipedia.org/wiki/Inverter_(logic_gate)" target="_blank">classical NOT gate</a>.
				Pauli&nbsp;X gates have the following matrix form:
			</p>
			<div class="center">
				<div class="matrix">
					<div class="matrix-bracket-left"></div>
					<div class="matrix-bracket-right"></div>
					<table>
						<tr>
							<td>0</td><td>1</td>
						</tr>
						<tr>
							<td>1</td><td>0</td>
						</tr>
					</table>
				</div>
				<a href="#.PAULI_X">Pauli X gate</a>
			</div>
			<p>
				We can now apply the
				<a href="#.PAULI_X">Pauli X gate</a>
				to the
				<a href="Q-Qubit.html#.HORIZONTAL">Horizontal qubit</a>
				by multiplying their matrices together.
			</p>
			<div class="center">
				<div class="matrix">
					<div class="matrix-bracket-left"></div>
					<div class="matrix-bracket-right"></div>
					<table>
						<tr>
							<td>0</td><td>1</td>
						</tr>
						<tr>
							<td>1</td><td>0</td>
						</tr>
					</table>
				</div>
				×
				<div class="matrix qubit">
					<div class="matrix-bracket-left"></div>
					<div class="matrix-bracket-right"></div>
					<table>
						<tr><td>1</td></tr>
						<tr><td>0</td></tr>
					</table>
				</div>
				=
				<div class="matrix qubit">
					<div class="matrix-bracket-left"></div>
					<div class="matrix-bracket-right"></div>
					<table>
						<tr><td>0</td></tr>
						<tr><td>1</td></tr>
					</table>
				</div>
			</div>
			<p>
				As anticipated, the resulting product matrix represents a 
				<a href="Q-Qubit.html#.VERTICAL">Vertical qubit</a>.
				(<a href="https://en.wiktionary.org/wiki/warm_fuzzy" target="_blank">Warm fuzzies</a> all around.)
			</p>
			<p>
				Note how the gate’s matrix 
				is the first factor
				and the qubit’s matrix is the second factor.
				The order matters because matrix multiplication is <strong>not</strong>
				<a href="https://en.wikipedia.org/wiki/Commutative_property#Commutative_operations_in_mathematics" target="_blank">commutative</a>. 
				With plain numbers 
				the order of the factors 
				does not change the product outcome.
				<span class="maths">a × b = b × a</span>.
				But with matrices the order does matter.
				<span class="maths">[&nbsp;a&nbsp;] × [&nbsp;b&nbsp;] ≠ [&nbsp;b&nbsp;] × [&nbsp;a&nbsp;]</span>.
				See <a href="https://en.wikipedia.org/wiki/Matrix_multiplication" target="_blank">matrix multiplication</a>
				for an in-depth explanation.
			</p>
			<h4>Applying gates with code</h4>
			<p>
				Let’s look at three different ways
				to apply a gate to a qubit
				using Q’s API.
				In this first example we will access
				our gate’s matrix directly
				and multiply it against our qubit—which is itself a matrix.
				(<code><a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a></code> extends <code><a href="Q.html">Q</a>.<a href="Q-Matrix.html">Matrix</a></code>
				and thereby inherits <code><a href="Q.html">Q</a>.<a href="Q-Matrix.html">Matrix</a></code>’s methods.
				Meanwhile, <code><a href="Q.html">Q</a>.Gate</code> does not extend <code><a href="Q.html">Q</a>.<a href="Q-Matrix.html">Matrix</a></code>,
				as it is sometimes desirable to create gates without matrices.
				See <a href="#Gates_without_matrices">Gates without matrices</a> below for more details.)
			</p>
<pre><code>
<a href="Q.html">Q</a>.Gate.<a href="#.PAULI_X">PAULI_X</a>
	.<a href="#this.matrix">matrix</a>
	.<a href="Q-Matrix.html#.prototype.multiply">multiply</a>( <a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a>.<a href="Q-Qubit.html#.HORIZONTAL">HORIZONTAL</a> )
	.<a href="Q-Matrix.html#.prototype.isEqualTo">isEqualTo</a>( <a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a>.<a href="Q-Qubit.html#.VERTICAL">VERTICAL</a> )</code>
<samp>true</samp></pre>
 			<p>
 				Rather than access our gate’s matrix directly,
 				we can instead call the instance method
 				<code><a href="#this.applyToQubit">applyToQubit</a></code>.
 			</p>
<pre><code>
<a href="Q.html">Q</a>.Gate.<a href="#.PAULI_X">PAULI_X</a>
	.<a href="#this.applyToQubit">applyToQubit</a>( <a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a>.<a href="Q-Qubit.html#.HORIZONTAL">HORIZONTAL</a> )
	.<a href="Q-Matrix.html#.prototype.isEqualTo">isEqualTo</a>( <a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a>.<a href="Q-Qubit.html#.VERTICAL">VERTICAL</a> )</code>
<samp>true</samp></pre>
 			<p>
 				We can also begin with the qubit
 				rather than the gate.
 			</p>
<pre><code>
<a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a>.<a href="Q-Qubit.html#.HORIZONTAL">HORIZONTAL</a>
	.<a href="Q-Qubit.html#.prototype.applyGate">applyGate</a>( <a href="Q.html">Q</a>.Gate.<a href="#.PAULI_X">PAULI_X</a> )
	.<a href="Q-Matrix.html#.prototype.isEqualTo">isEqualTo</a>( <a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a>.<a href="Q-Qubit.html#.VERTICAL">VERTICAL</a> )</code>
<samp>true</samp></pre>
			<h4>Gates without matrices</h4>
			<p>
				In quantum computing theory a quantum gate <strong>is</strong> a matrix.
				But Q expands this notion of a “gate” 
				to the more abstract notion of an “operation”—any function
				that is performed upon a qubit.
				This allows us to build custom “gates” that 
				perform data visualizations,
				trigger interface changes,
				and so on.
			</p>
			<h4>The punchline</h4>
			<p>
				While applying gates to qubits in the above fashion is useful
				for some debugging and 
				for building single-qubit state visualizations,
				it has no practical use for 
				full circuit evaluation as 
				it cannot represent the state of 
				a multiple-qubit system, let alone 
				<a href="https://en.wikipedia.org/wiki/Bell_state" target="_blank">quantum entanglement</a>. 
				For that we will need a proper 
				<code><a href="Q-Circuit.html">Circuit</a></code> class
				for simulating multi-qubit states.
			</p>




			<hr>
			<h3 id="Constructor">Constructor</h3>
			<p>
				<span class="constructor">Gate</span>
				<code class="value-type">Function( params: Object ) => <a href="Q.html">Q</a>.Gate</code>
				<br>
				Expects a single object whose properties
				will be applied directly to this gate instance.
				No particular properties are required
				and even the object argument itself is optional.
				The properties <em>not</em> listed as “optional” below
				are ones that will be assigned defaults
				upon instantiation by the constructor. 
				Any remaining properties listed below would be undefined
				unless supplied as arguments.
			</p>
			<p>
				Here we will create a <a href="https://en.wikipedia.org/wiki/Guppy" target="_blank">“gup”</a> gate
				that borrows its <code><a href="#this.matrix">matrix</a></code> property
				from the pre-existing <code><a href="#.PAULI_X">PAULI_X</a></code> gate
				<a href="#.constantss">constant</a>.
				This will enable our custom gate
				to flip 
				<a href="Q-Qubit.html">qubits</a> from a 
				<a href="Q-Qubit.html#.HORIZONTAL">horizontal state</a>, 
				ie. “off” or <span class="complex-vector ket">0</span>,
				to a <a href="Q-Qubit.html#.VERTICAL">vertical state</a>, 
				ie. “on” or <span class="complex-vector ket">1</span>,
				and back again—just like a 
				<code><a href="#.PAULI_X">PAULI_X</a></code> gate.
			</p>
<pre><code>
var gup = new <a href="Q.html">Q</a>.Gate({

	<a href="#this.symbol">symbol</a>:  'G',
	<a href="#this.name">name</a>:    'Gup',
	<a href="#this.nameCss">nameCss</a>: 'gup',<!--	
	<a href="#this.description">description</a>: 'This “gup” gate flips qubits.', -->
	<a href="#this.matrix">matrix</a>:   <a href="Q.html">Q</a>.Gate.<a href="#.PAULI_X">PAULI_X</a>.<a href="#this.matrix">matrix</a>
})
</code></pre>
			<p>
				We can now test that our new 
				<code>gup</code> gate 
				flips qubit states between <span class="complex-vector ket">0</span>
				and <span class="complex-vector ket">1</span>.
			</p>
<pre>

<code><span class="comment">//  Verify a “Horizontal” qubit has a value of |0⟩
//  and a “Vertical” qubit has a value of |1⟩.</span>

<a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a>.<a href="Q-Qubit.html#.HORIZONTAL">HORIZONTAL</a>.<a href="Q-Qubit.html#this.toStateVectorText">toStateVectorText</a>()</code>
<samp>"|0⟩"</samp>

<code><a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a>.<a href="Q-Qubit.html#.VERTICAL">VERTICAL</a>.<a href="Q-Qubit.html#this.toStateVectorText">toStateVectorText</a>()</code>
<samp>"|1⟩"</samp>


<code><span class="comment">//  Now flip a “Horizontal” |0⟩ to a “Vertical” |1⟩
//  and flip a “Vertical” |1⟩ to a “Horizontal” |0⟩.</span>

gup.<a href="#this.applyToQubit">applyToQubit</a>( <a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a>.<a href="Q-Qubit.html#.HORIZONTAL">HORIZONTAL</a> )
	.<a href="Q-Qubit.html#this.toStateVectorText">toStateVectorText</a>()</code>
<samp>"|1⟩"</samp>

<code>gup.<a href="#this.applyToQubit">applyToQubit</a>( <a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a>.<a href="Q-Qubit.html#.VERTICAL">VERTICAL</a> )
	.<a href="Q-Qubit.html#this.toStateVectorText">toStateVectorText</a>()</code>
<samp>"|0⟩"</samp></pre>
			<p>
				We can similarly use a qubit’s 
				<code><a href="Q-Qubit.html#.prototype.applyGate">applyGate</a></code> method
				which internally calls a gate’s 
				<code><a href="#this.applyToQubit">applyToQubit</a></code> method:
			</p>
<pre><code>
<a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a>.<a href="Q-Qubit.html#.HORIZONTAL">HORIZONTAL</a>      <span class="comment">//  Value begins at |0⟩.</span>
	.<a href="Q-Qubit.html#.prototype.applyGate">applyGate</a>( gup )   <span class="comment">//  Value is now |1⟩.</span>
	.<a href="Q-Qubit.html#this.toStateVectorText">toStateVectorText</a>()<span class="comment">//  Output that as text.</span></code>
<samp>"|1⟩"</samp>

<code><a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a>.<a href="Q-Qubit.html#.VERTICAL">VERTICAL</a>        <span class="comment">//  Value begins at |1⟩.</span>
	.<a href="Q-Qubit.html#.prototype.applyGate">applyGate</a>( gup )   <span class="comment">//  Value is now |0⟩.</span>
	.<a href="Q-Qubit.html#this.toStateVectorText">toStateVectorText</a>()<span class="comment">//  Output that as text.</span></code>
<samp>"|0⟩"</samp></pre>

			<p>
				We can also do this in one go:
			</p>
<pre><code>
<a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a>.<a href="Q-Qubit.html#.HORIZONTAL">HORIZONTAL</a>      <span class="comment">//  Value begins at |0⟩.</span>
	.<a href="Q-Qubit.html#.prototype.applyGate">applyGate</a>( gup )   <span class="comment">//  Value is now |1⟩.</span>
	.<a href="Q-Qubit.html#.prototype.applyGate">applyGate</a>( gup )   <span class="comment">//  Value is back to |0⟩.</span>
	.<a href="Q-Qubit.html#this.toStateVectorText">toStateVectorText</a>()<span class="comment">//  Output that as text.</span></code>
<samp>"|0⟩"</samp></pre>

			<ul class="properties">
				<li>
					<dt id="this.symbol">symbol</dt>
					<dd>
						<code class="value-type">String</code>
						One or two non-numeric characters
						used as a unique identifier among gates,
						and as a label in visual representations
						such as circuit diagrams.
						Will default to <code>"?"</code> if undefined at creation.
					</dd>
				</li>
				<li>
					<dt id="this.symbolAmazonBraket">symbolAmazonBraket</dt>
					<dd>
						<code class="value-type">String</code>
						Identifier to be used for this gate
						when exporting circuit data
						as <a href="https://aws.amazon.com/braket/" target="_blank">Amazon Braket</a> code.
						If not supplied to the constructor,
						<code>Gate</code> will define this value as 
						<code>this.<a href="#this.symbol">symbol</a>.toLowerCase()</code>.
					</dd>
				</li>
				<li>
					<dt id="this.symbolSvg">symbolSvg</dt>
					<dd>
						<code class="value-type">String [optional]</code>
						A visual representation of this gate’s symbol 
						in <a href="https://en.wikipedia.org/wiki/Scalable_Vector_Graphics" target="_blank">scalable vector graphic</a> format.
					</dd>
				</li>
				<li>
					<dt id="this.name">name</dt>
					<dd>
						<code class="value-type">String</code>
						The full name of this gate 
						to be used as a title or long label 
						in a visual representations, etc.
						Will default to <code>"Unknown"</code> if undefined at creation.
					</dd>
				</li>
				<li>
					<dt id="this.nameCss">nameCss</dt>
					<dd>
						<code class="value-type">String</code>
						Identifier to be used in constructing a 
						<a href="https://en.wikipedia.org/wiki/Cascading_Style_Sheets" target="_blank">Cascading Style Sheet</a> class name
						as defined in <code>Q-Circuit-Editor.css</code>.
						Will default to <code>"unknown"</code> if undefined at creation.
					</dd>
				</li>
				<!-- li>
					<dt id="this.description">description</dt>
					<dd>
						<code class="value-type">String [optional]</code>
						Text describing the intended use of this gate.
					</dd>
				</li -->
				<li>
					<dt id="this.matrix">matrix</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.<a href="Q-Matrix.html">Matrix</a> [optional]</code>
						The matrix representation of this gate operation’s logic,
						if one exists. 
						(All true quantum gates will have a matrix representation,
						but some visualization operations—such as
						the creation of a 
						<a href="Q-Qubit.html#Bloch_sphere">Bloch sphere</a>—will not.)
					</dd>
				</li>
				<li>
					<dt id="this.applyToQubit">applyToQubit</dt>
					<dd>
						<code class="value-type">Function</code>
						An action to be performed upon an input 
						<code><a href="Q-Qubit.html">Qubit</a></code> instance.
						If not supplied to the <code>Gate</code> constructor,
						<code>Gate</code> will create an operation
						that multiplies the input qubit by the gate instance’s 
						<code><a href="#this.matrix">matrix</a></code>.
						If the gate instance’s 
						<code><a href="#this.matrix">matrix</a></code> is undefined,
						<code>Gate</code> will create an operation
						that simply returns the input qubit untouched.
						While this is useful 
						for inspection and debugging a single gate’s functionality, 
						or building a visualization of a single qubit’s changing state, 
						it has no practical use for circuit evaluation 
						as it cannot represent the state of a multiple-qubit system, 
						let alone entanglement. 
					</dd>
				</li>
				<li>
					<dt id="this.index">index</dt>
					<dd>
						<code class="value-type">Number</code>
						An auto-incrementing identification number assigned to the instance,
						used for minding the total number of instances created.
					</dd>
				</li>
			</ul>
			<hr>
			<h3>Static properties</h3>
			<ul class="properties">
				<li>
					<dt id=".index">index</dt>
					<dd>
						<code class="value-type">Number</code>
						The number of instances created so far.
					</dd>
				</li>
				<li>
					<dt id=".findBy">findBy</dt>
					<dd>
						<code class="value-type">Function( key: String, value: * ) ⇒ Q.Gate</code>
						Returns the first object within
						<code><a href="Q.html">Q</a>.Gate.<a href="#.constants">constants</a></code>
						to satisfy the constraint
						<code>object[ key ] === value</code>.
					</dd>
				</li>
				<li>
					<dt id=".findBySymbol">findBySymbol</dt>
					<dd>
						<code class="value-type">Function( symbol: String ) ⇒ Q.Gate</code>
						Returns the result of calling
						the static method <code><a href="#.findBy">findBy</a></code> with 
						<code>"symbol"</code> as the <code>key</code> argument
						and <code>symbol</code> as the value argument.
					</dd>
				</li>
				<li>
					<dt id=".findByName">findByName</dt>
					<dd>
						<code class="value-type">Function( name: String ) ⇒ Q.Gate</code>
						Returns the result of calling
						the static method <code><a href="#.findBy">findBy</a></code> with 
						<code>"name"</code> as the <code>key</code> argument
						and <code>name</code> as the value argument.
					</dd>
				</li>			
			</ul>
			



			<h4>Constants and constant creation</h4>
			<ul class="properties">
				<li>
					<dt id=".constants">constants</dt>
					<dd>
						<code class="value-type">Object</code>
						Constants are appended <em>directly</em> to the 
						<code><a href="Q.html">Q</a>.Gate</code> object.
						For convenience they are also appended to this
						<code><a href="Q.html">Q</a>.Gate</code>.constants</code> object
						to make looking up constants in the JavaScript console trivial,
						and to make iterating across all constants convenient via functions like 
						<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" target="_blank">Object.entries</a></code>,
						<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank">Object.keys</a></code>,
						<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values" target="_blank">Object.values</a></code>,
						and so on.
						<!-- Configured to be unwritable once appended via
						<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank">Object.defineProperty</a></code>
						and they are labeled in uppercase to signal to us that this is so. -->
						The intention that a property act as a constant is signaled 
						by its labelling in all-uppercase.
					</dd>
				</li>
				<li>
					<dt id=".createConstant">createConstant</dt>
					<dd>
						<code class="value-type">Function( key: String, value: * )<!-- → undefined --></code>
						Appends a property named by <code>key</code> 
						with a value of <code>value</code>
						to both the 
						<code>Gate</code> object 
						and its <code><a href="#.constants">constants</a></code> property.
					</dd>
				</li>
				<li>
					<dt id=".createConstants">createConstants</dt>
					<dd>
						<code class="value-type">Function( … )</code>
						Expects an even number of arguments.
						Will use each pair in the sequence of arguments to call
						<code><a href="#.createConstant">createConstant</a></code>.
					</dd>
				</li>
			</ul>
			<br>
			



			<h5>Gates of small consequence</h5>
			<ul class="properties">
				<li>
					<dt id=".IDENTITY">IDENTITY</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Gate</code>
						An Identity gate has no effect on the value of the qubit it operates on;
						equivalent to multiplying a value by one.
						(Generally when a circuit is created from text or another source,
						any included identity gates are ignored.
						It is included here for completeness.)
<pre><code>
new <a href="Q.html">Q</a>.Gate({

	<a href="#this.symbol">symbol</a>:  'I',<!-- <a href="#this.symbolAmazonBraket">symbolAmazonBraket</a>: 'i', -->
	<a href="#this.name">name</a>:    'Identity',
	<a href="#this.nameCss">nameCss</a>: 'identity',
	<a href="#this.matrix">matrix</a>:   <a href="Q.html">Q</a>.<a href="Q-Matrix.html">Matrix</a>.<a href="Q-Matrix.html#.IDENTITY_2X2">IDENTITY_2X2</a>
})
</code></pre>
						Matrix representation as declared in 
						<code><a href="Q.html">Q</a>.<a href="Q-Matrix.html">Matrix</a>.<a href="Q-Matrix.html#.IDENTITY_2X2">IDENTITY_2X2</a></code>:
						<div class="maths">
							<div class="matrix">
								<div class="matrix-bracket-left"></div>
								<div class="matrix-bracket-right"></div>
								<table>
									<tr>
										<td>1</td><td>0</td>
									</tr>
									<tr>
										<td>0</td><td>1</td>
									</tr>
								</table>
							</div>
						</div>
					</dd>
				</li>
				<li>
					<dt id=".CURSOR">CURSOR</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Gate</code>
						Mathematically the “identity cursor” is equivalent
						to the <code><a href="#.IDENTITY">IDENTITY</a></code> gate,
						however it is used by the visual circuit editor
						as a placeholder when a user is building 
						<a href="https://en.wikipedia.org/wiki/Quantum_logic_gate#Controlled_(cX_cY_cZ)_gates" target="_blank">controlled gates</a>
						 or 
						 <a href="https://en.wikipedia.org/wiki/Quantum_logic_gate#Swap_(SWAP)_gate" target="_blank">swap gates</a>
						(which operate on multiple qubits)
						from individual components.
						This is a novel Q invention.
<pre><code>
new <a href="Q.html">Q</a>.Gate({

	<a href="#this.symbol">symbol</a>:  '*',<!-- <a href="#this.symbolAmazonBraket">symbolAmazonBraket</a>: 'i', -->
	<a href="#this.name">name</a>:    'Identity',
	<a href="#this.nameCss">nameCss</a>: 'identity',
	<a href="#this.matrix">matrix</a>:   <a href="Q.html">Q</a>.<a href="Q-Matrix.html">Matrix</a>.<a href="Q-Matrix.html#.IDENTITY_2X2">IDENTITY_2X2</a>
})
</code></pre>
						Matrix representation as declared in 
						<code><a href="Q.html">Q</a>.<a href="Q-Matrix.html">Matrix</a>.<a href="Q-Matrix.html#.IDENTITY_2X2">IDENTITY_2X2</a></code>:
						<div class="maths">
							<div class="matrix">
								<div class="matrix-bracket-left"></div>
								<div class="matrix-bracket-right"></div>
								<table>
									<tr>
										<td>1</td><td>0</td>
									</tr>
									<tr>
										<td>0</td><td>1</td>
									</tr>
								</table>
							</div>
						</div>
					</dd>
				</li>			
			</ul>
			



			<h5>Standard single-qubit gates</h5>
			<ul class="properties">
				<li>
					<dt id=".HADAMARD">HADAMARD</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Gate</code>
						Applies a <a href="https://en.wikipedia.org/wiki/Quantum_logic_gate#Hadamard_(H)_gate" target="_blank">Hadamard transform</a> to a single qubit.
						For the basis qubit states of 
						<span class="complex-vector ket">0</span> and 
						<span class="complex-vector ket">1</span> 
						this has the effect of putting a qubit into <a href="https://en.wikipedia.org/wiki/Quantum_superposition" target="_blank">superposition</a>.
						It represents a rotation on the 
						<a href="Q-Qubit.html#Bloch_sphere">Bloch sphere</a>
						around the Z-axis by π radians,
						followed by a rotation 
						around the Y-axis by π÷2 radians.
<pre><code>
new <a href="Q.html">Q</a>.Gate({

	<a href="#this.symbol">symbol</a>:  'H',<!-- <a href="#this.symbolAmazonBraket">symbolAmazonBraket</a>: 'h', -->
	<a href="#this.name">name</a>:    'Hadamard',
	<a href="#this.nameCss">nameCss</a>: 'hadamard',
	<a href="#this.matrix">matrix</a>:   <a href="Q.html">Q</a>.<a href="Q-Matrix.html">Matrix</a>(

		[ Math.SQRT1_2,  Math.SQRT1_2 ],
		[ Math.SQRT1_2, -Math.SQRT1_2 ]
	)
})
</code></pre>
						Matrix representation:
						<div class="maths">
							<div class="matrix">
								<div class="matrix-bracket-left"></div>
								<div class="matrix-bracket-right"></div>
								<table>
									<tr>
										<td>1</td><td>1</td>
									</tr>
									<tr>
										<td>1</td><td>-1</td>
									</tr>
								</table>
							</div>
							×
							<table class="division">
								<tr class="dividend"><td>1</td></tr>
								<tr class="divisor"><td>√ 2</td></tr>
							</table>
						</div>
					</dd>
				</li>
				<li>
					<dt id=".PAULI_X">PAULI_X</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Gate</code>
						The <a href="https://en.wikipedia.org/wiki/Quantum_logic_gate#Pauli-X_gate" target="_blank">Pauli X gate</a>
						represents a rotation on the 
						<a href="Q-Qubit.html#Bloch_sphere">Bloch sphere</a>
						around the <strong>X</strong>-axis by π radians.
						It is the quantum equivalent of
						the <a href="https://en.wikipedia.org/wiki/Inverter_(logic_gate)" target="_blank">classical NOT gate</a>
						in that it maps 
						<span class="complex-vector ket">0</span> to <span class="complex-vector ket">1</span>
						and
						<span class="complex-vector ket">1</span> to <span class="complex-vector ket">0</span>.
<pre><code>
new <a href="Q.html">Q</a>.Gate({

	<a href="#this.symbol">symbol</a>:  'X',<!-- <a href="#this.symbolAmazonBraket">symbolAmazonBraket</a>: 'x', -->
	<a href="#this.name">name</a>:    'Pauli X',
	<a href="#this.nameCss">nameCss</a>: 'pauli-x',
	<a href="#this.matrix">matrix</a>:   <a href="Q.html">Q</a>.<a href="Q-Matrix.html">Matrix</a>(

		[ 0, 1 ],
		[ 1, 0 ]
	)
})
</code></pre>
						Matrix representation:
						<div class="maths">
							<div class="matrix">
								<div class="matrix-bracket-left"></div>
								<div class="matrix-bracket-right"></div>
								<table>
									<tr>
										<td>0</td><td>1</td>
									</tr>
									<tr>
										<td>1</td><td>0</td>
									</tr>
								</table>
							</div>
						</div>
					</dd>
				</li>
				<li>
					<dt id=".PAULI_Y">PAULI_Y</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Gate</code>
						The <a href="https://en.wikipedia.org/wiki/Quantum_logic_gate#Pauli-Y_gate" target="_blank">Pauli Y gate</a>
						represents a rotation on the 
						<a href="Q-Qubit.html#Bloch_sphere">Bloch sphere</a>
						around the <strong>Y</strong>-axis by π radians.
						It maps 
						<span class="complex-vector ket">0</span> to <span class="symbol">i</span><span class="complex-vector ket">1</span>
						and
						<span class="complex-vector ket">1</span> to -<span class="symbol">i</span><span class="complex-vector ket">0</span>.
<pre><code>
new <a href="Q.html">Q</a>.Gate({

	<a href="#this.symbol">symbol</a>:  'Y',<!-- <a href="#this.symbolAmazonBraket">symbolAmazonBraket</a>: 'y', -->
	<a href="#this.name">name</a>:    'Pauli Y',
	<a href="#this.nameCss">nameCss</a>: 'pauli-y',
	<a href="#this.matrix">matrix</a>:   <a href="Q.html">Q</a>.<a href="Q-Matrix.html">Matrix</a>(

		[ 0, new <a href="Q.html">Q</a>.<a href="Q-ComplexNumber.html">ComplexNumber</a>( 0, -1 )],
		[ new <a href="Q.html">Q</a>.<a href="Q-ComplexNumber.html">ComplexNumber</a>( 0, 1 ), 0 ]
	)
})
</code></pre>
						Matrix representation:
						<div class="maths">
							<div class="matrix">
								<div class="matrix-bracket-left"></div>
								<div class="matrix-bracket-right"></div>
								<table>
									<tr>
										<td>0</td><td class="symbol">-i</td>
									</tr>
									<tr>
										<td class="symbol">i</td><td>0</td>
									</tr>
								</table>
							</div>
						</div>
					</dd>
				</li>
				<li>
					<dt id=".PAULI_Z">PAULI_Z</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Gate</code>
						The <a href="https://en.wikipedia.org/wiki/Quantum_logic_gate#Pauli-Z_gate" target="_blank">Pauli Z gate</a>
						represents a rotation on the 
						<a href="Q-Qubit.html#Bloch_sphere">Bloch sphere</a>
						around the <strong>Z</strong>-axis by π radians.
						It is a special case of a <a href="#.PHASE">Phase shift gate</a>
						where ϕ = π, and is therefore sometimes referred to as a “phase-flip” gate.
						It leaves the basis state <span class="complex-vector ket">0</span> unchanged 
						and maps <span class="complex-vector ket">1</span>  to -<span class="complex-vector ket">1</span>.
<pre><code>
new <a href="Q.html">Q</a>.Gate({

	<a href="#this.symbol">symbol</a>:  'Z',<!-- <a href="#this.symbolAmazonBraket">symbolAmazonBraket</a>: 'z', -->
	<a href="#this.name">name</a>:    'Pauli Z',
	<a href="#this.nameCss">nameCss</a>: 'pauli-z',
	<a href="#this.matrix">matrix</a>:   <a href="Q.html">Q</a>.<a href="Q-Matrix.html">Matrix</a>(

		[ 1,  0 ],
		[ 0, -1 ]
	)
})
</code></pre>
						Matrix representation:
						<div class="maths">
							<div class="matrix">
								<div class="matrix-bracket-left"></div>
								<div class="matrix-bracket-right"></div>
								<table>
									<tr>
										<td>1</td><td>0</td>
									</tr>
									<tr>
										<td>0</td><td>-1</td>
									</tr>
								</table>
							</div>
						</div>
					</dd>
				</li>
				<li>
					<dt id=".PHASE">PHASE</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Gate</code>
						<a href="https://en.wikipedia.org/wiki/Quantum_logic_gate#Phase_shift_(%20'%22%60UNIQ--postMath-00000038-QINU%60%22'%20)_gates" target="_blank">Phase gates</a>
						are a family of quantum gates
						that employ the variable ϕ (phi) to
						represent tracing a horizontal arc (a line of latitude)
						of ϕ radians
						around the 
						<a href="Q-Qubit.html#Bloch_sphere">Bloch sphere</a>.
						They leave the basis state <span class="complex-vector ket">0</span> unchanged
						and map <span class="complex-vector ket">1</span> to 
						<span class="symbol">e</span><sup><span class="symbol">i</span>ϕ</sup>
						<span class="complex-vector ket">1</span>. 
						The probability of measuring a 
						<span class="complex-vector ket">0</span>
						or
						<span class="complex-vector ket">1</span>
						is unchanged after applying a phase shift, 
						however it modifies the phase of the quantum state.
						This particular form 
						used for our <code>PHASE</code> constant
						represents a rotation on the 
						<a href="Q-Qubit.html#Bloch_sphere">Bloch sphere</a>
						around the Z-axis of π ÷ 2 radians.
<pre><code>
new <a href="Q.html">Q</a>.Gate({

	<a href="#this.symbol">symbol</a>:  'P',<!-- <a href="#this.symbolAmazonBraket">symbolAmazonBraket</a>: 'p', -->
	<a href="#this.name">name</a>:    'Phase',
	<a href="#this.nameCss">nameCss</a>: 'phase',
	updateMatrix$: function( phi ){

		if( <a href="Q.html">Q</a>.<a href="Q.html#.isUsefulNumber">isUsefulNumber</a>( phi ) === true ) this.phi = phi
		this.matrix = new <a href="Q.html">Q</a>.<a href="Q-Matrix.html">Matrix</a>(
			[ 1, 0 ],
			[ 0, <a href="Q.html">Q</a>.<a href="Q-ComplexNumber.html">ComplexNumber</a>.<a href="Q-ComplexNumber.html#.E">E</a>.<a href="Q-ComplexNumber.html#.prototype.power">power</a>( new <a href="Q.html">Q</a>.<a href="Q-ComplexNumber.html">ComplexNumber</a>( 0, this.phi ))]
		return this
	},
	<a href="#this.applyToQubit">applyToQubit</a>: function( qubit, phi ){

		if( <a href="Q.html">Q</a>.<a href="Q.html#.isUsefulNumber">isUsefulNumber</a>( phi ) !== true ) phi = this.phi
		const matrix = new <a href="Q.html">Q</a>.<a href="Q-Matrix.html">Matrix</a>(
		
			[ 1, 0 ],
			[ 0, <a href="Q.html">Q</a>.<a href="Q-ComplexNumber.html">ComplexNumber</a>.<a href="Q-ComplexNumber.html#.E">E</a>.<a href="Q-ComplexNumber.html#.prototype.power">power</a>( new <a href="Q.html">Q</a>.<a href="Q-ComplexNumber.html">ComplexNumber</a>( 0, phi ))]
		)
		return new <a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a>( matrix.<a href="Q-Matrix.html#.prototype.multiply">multiply</a>( qubit ))
	}
})
</code></pre>
						Note that there is no explicitly defined <code>matrix</code> property.
						It will be created upon instantiation 
						when the <a href="#Constructor">constructor</a>
						calls the argument object’s <code>updateMatrix$</code> function.
						Matrix representation (when ϕ = 1):
						<div class="maths">
							<div class="matrix">
								<div class="matrix-bracket-left"></div>
								<div class="matrix-bracket-right"></div>
								<table>
									<tr>
										<td>1</td><td>0</td>
									</tr>
									<tr>
										<td>0</td><td class="symbol">e<sup>i</sup></td>
									</tr>
								</table>
							</div>
						</div>
						<br>
						Using varying values for ϕ is easy.
						We can clone this <a href="#.PHASE">PHASE</a> constant, 
						provide it a new <code><a href="#this.symbol">symbol</a></code>
						(so it has a unique identifier),
						and a new value for ϕ.
						In this example we create a gate called <code>fox</code>
						with a ϕ value of π.
<pre><code>
var fox = <a href="Q.html">Q</a>.Gate.<a href="#.PHASE">PHASE</a>.<a href="#.prototype.clone">clone</a>({ symbol: 'F', phi: Math.PI })
</code></pre>
						Our value of ϕ is now set equal to π
						and we can apply this gate to any qubit.
<pre><code>
fox.<a href="#this.applyToQubit">applyToQubit</a>( <a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a>.<a href="Q-Qubit.html#.DIAGONAL">DIAGONAL</a> ).<a href="Q-Matrix.html#.prototype.toTsv">toTsv</a>()</code>
<samp>"
 0.707
-0.707"
</samp></pre>
						But we can also send a 
						<em>temporary</em> value for ϕ
						that will be used only during this function execution;
						it will not change <code>fox</code>’s set value of ϕ.
						Let’s try temporarily setting ϕ to π ÷ 4.
<pre><code>
fox.<a href="#this.applyToQubit">applyToQubit</a>( <a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a>.<a href="Q-Qubit.html#.DIAGONAL">DIAGONAL</a>, Math.PI / 4 ).<a href="Q-Matrix.html#.prototype.toTsv">toTsv</a>()</code>
<samp>"
 0.707
 0.5 + 0.5i"
</samp></pre>
						Rather than begin our expression 
						with a gate,
						we can instead begin with a qubit,
						and then apply our <code>fox</code> gate to it.
<pre><code>
<a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a>.<a href="Q-Qubit.html#.DIAGONAL">DIAGONAL</a>
	.<a href="Q-Qubit.html#.prototype.applyGate">applyGate</a>( fox )
	.<a href="Q-Matrix.html#.prototype.toTsv">toTsv</a>()</code>
<samp>"
 0.707
-0.707"
</samp></pre>
						But what’s more clever is that additional arguments
						will be passed directly to the gate’s 
						<code><a href="#this.applyToQubit">applyToQubit</a></code> method,
						so we can still use temporary values for ϕ.
<pre><code>
<a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a>.<a href="Q-Qubit.html#.DIAGONAL">DIAGONAL</a>
	.<a href="Q-Qubit.html#.prototype.applyGate">applyGate</a>( fox, Math.PI / 4 )
	.<a href="Q-Matrix.html#.prototype.toTsv">toTsv</a>()</code>
<samp>"
 0.707
 0.5 + 0.5i"
</samp></pre>

					</dd>
				</li>
				<li>
					<dt id=".PI_8">PI_8</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Gate</code>
						The π ÷ 8 gate 
						is a special case of a <a href="#.PHASE">Phase shift gate</a>
						where the ϕ (phi) variable is set to π ÷ 4.
						(But <a href="https://www.quora.com/Why-is-the-quantum-T-gate-called-pi-8-gate-as-it-only-adds-a-phase-difference-of-pi-4-instead-of-pi-8-to-the-state-vector-1" target="_blank">why is it called “π ÷ 8” when it actually divides π by 4?</a>)
						Like all phase shift gates, 
						it represents a rotation on the 
						<a href="Q-Qubit.html#Bloch_sphere">Bloch sphere</a>
						around the Z-axis.
<pre><code>
new <a href="Q.html">Q</a>.Gate({

	<a href="#this.symbol">symbol</a>:  'T',<!-- <a href="#this.symbolAmazonBraket">symbolAmazonBraket</a>: 't', -->
	<a href="#this.name">name</a>:    'π ÷ 8',
	<a href="#this.nameCss">nameCss</a>: 't',
	<a href="#this.matrix">matrix</a>:   <a href="Q.html">Q</a>.<a href="Q-Matrix.html">Matrix</a>(

		[ 1, 0 ],
		[ 0, <a href="Q.html">Q</a>.<a href="Q-ComplexNumber.html">ComplexNumber</a>.<a href="Q-ComplexNumber.html#.E">E</a>.<a href="Q-ComplexNumber.html#.prototype.power">power</a>( new <a href="Q.html">Q</a>.<a href="Q-ComplexNumber.html">ComplexNumber</a>( 0, Math.PI / 4 )) ]
	)
})
</code></pre>
						Matrix representation:
						<div class="maths">
							<div class="matrix">
								<div class="matrix-bracket-left"></div>
								<div class="matrix-bracket-right"></div>
								<table>
									<tr>
										<td>1</td><td>0</td>
									</tr>
									<tr>
										<td>0</td><td class="symbol">e<sup>iπ ÷ 4</sup></td>
									</tr>
								</table>
							</div>
						</div>
					</dd>
				</li>
			</ul>
			



			<h5>Multi-qubit gates</h5>
			<ul class="properties">
				<li>
					<dt id=".SWAP">SWAP</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Gate</code>
						The <a href="https://en.wikipedia.org/wiki/Quantum_logic_gate#Swap_(SWAP)_gate" target="_blank">Swap gate</a>
						swaps the value of two qubits.
						It is defined here
						with respect to the bases 
						<span class="complex-vector ket">00</span>,
						<span class="complex-vector ket">01</span>,
						<span class="complex-vector ket">10</span>, and
						<span class="complex-vector ket">11</span>.
<pre><code>
new <a href="Q.html">Q</a>.Gate({

	<a href="#this.symbol">symbol</a>:  'S',<!-- <a href="#this.symbolAmazonBraket">symbolAmazonBraket</a>: 's', -->
	<a href="#this.name">name</a>:    'Swap',
	<a href="#this.nameCss">nameCss</a>: 'swap',
	<a href="#this.matrix">matrix</a>:   <a href="Q.html">Q</a>.<a href="Q-Matrix.html">Matrix</a>(

			[ 1, 0, 0, 0 ],
			[ 0, 0, 1, 0 ],
			[ 0, 1, 0, 0 ],
			[ 0, 0, 0, 1 ])
	)
})
</code></pre>
						Matrix representation:
						<div class="maths">
							<div class="matrix">
								<div class="matrix-bracket-left"></div>
								<div class="matrix-bracket-right"></div>
								<table>
									<tr>
										<td>1</td><td>0</td><td>0</td><td>0</td>
									</tr>
									<tr>
										<td>0</td><td>0</td><td>1</td><td>0</td>
									</tr>
									<tr>
										<td>0</td><td>1</td><td>0</td><td>0</td>
									</tr>
									<tr>
										<td>0</td><td>0</td><td>0</td><td>1</td>
									</tr>
								</table>
							</div>
						</div>
					</dd>
				</li>
				<li>
					<dt id=".SWAP1_2">SWAP1_2</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Gate</code>
						The <a href="https://en.wikipedia.org/wiki/Quantum_logic_gate#Square_root_of_Swap_gate_(%E2%88%9ASWAP)" target="_blank">√Swap gate</a>
						performs half of a swap between two qubits.
						It is not maximally entangling.
						More than one application of it is required to produce a 
						<a href="https://en.wikipedia.org/wiki/Bell_state" target="_blank">Bell state</a>
						from its product states.
						It is defined here
						with respect to the bases 
						<span class="complex-vector ket">00</span>,
						<span class="complex-vector ket">01</span>,
						<span class="complex-vector ket">10</span>, and
						<span class="complex-vector ket">11</span>.
<pre><code>
new <a href="Q.html">Q</a>.Gate({

	<a href="#this.symbol">symbol</a>:  '√',<!-- 	<a href="#this.symbolAmazonBraket">symbolAmazonBraket</a>: 's', -->
	<a href="#this.name">name</a>:    '√Swap',
	<a href="#this.nameCss">nameCss</a>: 'swap1-2',
	<a href="#this.matrix">matrix</a>:   <a href="Q.html">Q</a>.<a href="Q-Matrix.html">Matrix</a>(

			[ 1, 0, 0, 0 ],
			[ 0, new <a href="Q.html">Q</a>.<a href="Q-ComplexNumber.html">ComplexNumber</a>( 0.5,  0.5 ), new <a href="Q.html">Q</a>.<a href="Q-ComplexNumber.html">ComplexNumber</a>( 0.5, -0.5 ), 0 ],
			[ 0, new <a href="Q.html">Q</a>.<a href="Q-ComplexNumber.html">ComplexNumber</a>( 0.5, -0.5 ), new <a href="Q.html">Q</a>.<a href="Q-ComplexNumber.html">ComplexNumber</a>( 0.5,  0.5 ), 0 ],
			[ 0, 0, 0, 1 ])
	)
})
</code></pre>
						Matrix representation:
						<div class="maths">
							<div class="matrix">
								<div class="matrix-bracket-left"></div>
								<div class="matrix-bracket-right"></div>
								<table>
									<tr>
										<td>1</td>
										<td>0</td>
										<td>0</td>
										<td>0</td>
									</tr>
									<tr>
										<td>0</td>
										<td>
											<table class="division">
												<tr class="dividend"><td>1</td></tr>
												<tr class="divisor"><td>2</td></tr>
											</table>
											×
											(1 + <span class="symbol">i</span>)
										</td>
										<td>
											<table class="division">
												<tr class="dividend"><td>1</td></tr>
												<tr class="divisor"><td>2</td></tr>
											</table>
											×
											(1 - <span class="symbol">i</span>)
										</td>
										<td>0</td>
									</tr>
									<tr>
										<td>0</td>
										<td>
											<table class="division">
												<tr class="dividend"><td>1</td></tr>
												<tr class="divisor"><td>2</td></tr>
											</table>
											×
											(1 - <span class="symbol">i</span>)
										</td>
										<td>
											<table class="division">
												<tr class="dividend"><td>1</td></tr>
												<tr class="divisor"><td>2</td></tr>
											</table>
											×
											(1 + <span class="symbol">i</span>)
										</td>
										<td>0</td>
									</tr>
									<tr>
										<td>0</td><td>0</td><td>0</td><td>1</td>
									</tr>
								</table>
							</div>
						</div>
					</dd>
				</li>
			</ul>




			<h5>Implicit gates</h5>
			<p>
				<code><a href="Q.html">Q</a>.<a href="Q-Circuit.html">Circuit</a></code> 
				supports several multi-qubit gates implictly
				through composition,
				rather than explicitly with <code>Gate</code> constants.
				For example,
				Q does not explictly define a 
				<a href="https://en.wikipedia.org/wiki/Controlled_NOT_gate" target="_blank">Controlled-Not (CNOT) gate</a>,
				<a href="https://en.wikipedia.org/wiki/Fredkin_gate" target="_blank">Controlled Swap (Fredkin) gate</a>,
				<a href="https://en.wikipedia.org/wiki/Toffoli_gate" target="_blank">Toffolli (CCNOT) gate</a>,
				and so on
				because they are all easily composed 
				by adding a control matrix
				to any existing gate matrix.
			</p>




			<hr>
			<h3 id="Prototype_properties">Prototype properties</h3>
			<ul class="properties">
				<li>
					<dt id=".prototype.clone">clone</dt>
					<dd>
						<code class="value-type">Function ⇒ <a href="Q.html">Q</a>.Gate</code>
						Returns a new <code>Gate</code> instance
						with properties cloned from this instance.
					</dd>
				</li>
				<li>
					<dt id=".prototype.applyToQubits">applyToQubits</dt>
					<dd>
						<code class="value-type">Function( <a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a>, … ) ⇒ Array</code>
						Calls the instance method 
						<code><a href="#this.applyToQubit">applyToQubit</a></code>
						for each supplied <code><a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a></code> argument
						and returns an Array of results.
						For example:
<pre><code>
<a href="Q.html">Q</a>.Gate.<a href="#.PAULI_X">PAULI_X</a>.<a href="#.prototype.applyToQubits">applyToQubits</a>( 

	<a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a>.<a href="Q-Qubit.html#.HORIZONTAL">HORIZONTAL</a>, 
	<a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a>.<a href="Q-Qubit.html#.VERTICAL">VERTICAL</a>,
	… 
)</code></pre>
						The above will return:
<pre><samp>
[
	<a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a>.<a href="Q-Qubit.html#.VERTICAL">VERTICAL</a>,
	<a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a>.<a href="Q-Qubit.html#.HORIZONTAL">HORIZONTAL</a>, 
	… 
]</samp></pre>
						Or for even more fun with Arrays of qubits:
<pre><code>
<a href="Q.html">Q</a>.Gate.<a href="#.IDENTITY">IDENTITY</a>
	.<a href="#.prototype.applyToQubits">applyToQubits</a>(

		...Object.values( <a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a>.<a href="Q-Qubit.html#.constants">constants</a> )
	)
	.map( <a href="Q.html">Q</a>.<a href="Q-Qubit.html">Qubit</a>.<a href="Q-Qubit.html#.prototype.toText">toText</a> )</code>
<samp>[
	" 1↵0",          <span class="comment">//  <a href="Q-Qubit.html#.HORIZONTAL">Horizontal</a></span>
	" 0↵1",          <span class="comment">//  <a href="Q-Qubit.html#.VERTICAL">Vertical</a></span>
	" 0.707↵ 0.707", <span class="comment">//  <a href="Q-Qubit.html#.DIAGONAL">Diagonal</a></span>
	" 0.707↵-0.707", <span class="comment">//  <a href="Q-Qubit.html#.ANTI_DIAGONAL">Anti-Diagonal</a></span>
	" 0.707↵-0.707i",<span class="comment">//  <a href="Q-Qubit.html#.RIGHT_HAND_CIRCULAR_POLARIZED">Right-hand Circular Polarized</a></span>
	" 0.707↵ 0.707i" <span class="comment">//  <a href="Q-Qubit.html#.LEFT_HAND_CIRCULAR_POLARIZED">Left-hand Circular Polarized</a></span>
]</samp></pre>


						While this is useful for inspection and debugging
						a single gate’s functionality,
						or building a visualization of a single qubit’s changing state,
						it has no practical use for circuit evaluation
						as it cannot represent the state of a multiple-qubit system,
						let alone entanglement.
						Will not return a <code><a href="Q.html">Q</a>.Gate</code> instance, 
						and therefore halts
						<a href="https://en.wikipedia.org/wiki/Fluent_interface" target="_blank">“Fluent interface” method chaining</a>
						along this prototype.
					</dd>
				</li>
				<li>
					<dt id=".prototype.set$">set$</dt>
					<dd>
						<code class="value-type">Function( key: String, value: * ) ⇒ <a href="Q.html">Q</a>.Gate</code>
						Sets a property on this instance 
						with a key of <code>key</code>
						and a value of <code>value</code>,
						then returns the instance.
					</dd>
				</li>
			</ul>
		</main>
		<script>




var gup = new Gate({

	symbol:  'G',
	name:    'Gup',
	nameCss: 'gup',
	matrix: Gate.PAULI_X.matrix
})




var fox = Gate.PHASE.clone({ symbol: 'F', phi: Math.PI })





//  Create the gate buttons.
/*
let 
gateTarget = Q.Gate.IDENTITY,
gateCurrent

const blochSphereGates = document.getElementById( 'bloch-sphere-gates' )
;[
	'IDENTITY',
	'HADAMARD',
	'PAULI_X',
	'PAULI_Y',
	'PAULI_Z',
	'PHASE',
	'PI_8'

].forEach( function( gateName ){

	const 
	gate = Q.Gate[ gateName ],
	gateContainerElement = document.createElement( 'div' ),
	gateElement = document.createElement( 'div' ),
	gateNameElement = document.createElement( 'p' )

	gateContainerElement.classList.add( 'bloch-sphere-gate-container' )
	gateContainerElement.setAttribute( 'data-gate',  gate.name )
	gateContainerElement.addEventListener( 'click', function(){

		gateTarget = gate
		changeBlochVector()
	})

	gateElement.classList.add( 'bloch-sphere-gate' )

	gateElement.setAttribute( 'title', gate.name )
	gateElement.innerText = gate.symbol
	gateContainerElement.appendChild( gateElement )

	gateNameElement.innerText = gate.name
	gateContainerElement.appendChild( gateNameElement )
	
	blochSphereGates.appendChild( gateContainerElement )
})
*/



		</script>
	</body>
</html>