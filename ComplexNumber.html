<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Q âŸ© ComplexNumber</title>
		<link rel="stylesheet" type="text/css" href="Assets/style.css">
		<script src="Source/Q.js"></script>
		<script src="Source/ComplexNumber.js"></script>
		<script src="Assets/navigation.js"></script>
	</head>
	<body>
		<main>
			<h3>Maths</h3>
			<p>
				The set of 
				<a href="https://en.wikipedia.org/wiki/Real_number" target="_blank">real numbers (â„)</a>
				contains any number that can be expressed 
				along an infinite timeline.
			</p>
<pre><code>
â€¦  -3  -2  -1   0  +1  +2  +3   â€¦  
â”„â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”¬â”€â”´â”€â”€â”¬â”´â”¬â”€â”€â”„  
                     âˆš2    ğ’† Ï€  

</pre></code>
			<p>
				Meanwhile, 
				<a href="https://en.wikipedia.org/wiki/Imaginary_number" target="_blank">imaginary numbers (ğ•€)</a>
				consist of a real (â„) multiplier and 
				the symbol ğ’Š, which is the impossible solution to the equation ğ’™Â² = âˆ’1. 
				Note that no number multiplied by itself can ever result in a 
				negative product, yet the concept of ğ’Š gives us a way to reason around 
				this imaginary scenario nonetheless. 
			</p>
<pre><code>
â€¦  -3ğ’Š -2ğ’Š  -1ğ’Š  0  +1ğ’Š +2ğ’Š +3ğ’Š  â€¦  
â”„â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”„  

</pre></code>
			<p>
				A <a href="https://en.wikipedia.org/wiki/Complex_number" target="_blank">complex number (â„‚)</a>
				is a number that can be expressed in the form 
				ğ’‚ + ğ’ƒğ’Š, where ğ’‚ is the real component (â„) and ğ’ƒğ’Š is the imaginary 
				component (ğ•€). 
			</p>
			<h3>Code</h3>
			<p>
				Operation functions on <code>Q.ComplexNumber</code> instances generally accept as 
				arguments both sibling instances and pure <code>Number</code> instances, though the 
				value returned is always an instance of <code>Q.ComplexNumber</code>.
			</p>
<pre><code>
var 
a = new Q.ComplexNumber( 1,  2 ),
b = new Q.ComplexNumber( 3, -4 ),
a_add_b      = a.add( b ),
a_subtract_b = a.subtract( b ),
a_multiply_b = a.multiply( b )
a_divide_b   = a.divide( b )

console.log( '' )
console.log( 'ğ’‚ =', a.toString() )
console.log( 'ğ’ƒ =', b.toString() )
console.log( '' )
console.log( 'ğ’‚ + ğ’ƒ = ', a_add_b.toString() )
console.log( 'ğ’‚ - ğ’ƒ =', a_subtract_b.toString() )
console.log( 'ğ’‚ Ã— ğ’ƒ =', a_multiply_b.toString() )
console.log( 'ğ’‚ Ã· ğ’ƒ =', a_divide_b.toString() )
console.log( '' )

</pre></code>

			<p>A reminder that ğ’ŠÂ² = -1.</p>
<pre><code>
var
i  = new Q.ComplexNumber( 0,  1 ),
ii = i.multiply( i )

console.log( 'ğ’Š  = ', i.toString() )
console.log( 'ğ’ŠÂ² =', ii.toString() )

</pre></code>		
		

			<h3>Class methods</h3>
			<p>
				TK
			</p>
			<h3>Instance methods</h3>
			<p>
				TK
			</p>
		</main>
		<script>




//  First, what do the docs have to say?

console.log( '\n\nQ.ComplexNumber\n', Q.extractDocumentation( Q.ComplexNumber ), '\n\n' )


//  Weâ€™re going to use `var` here instead of `let` or `const`
//  because itâ€™s more flexible for your console-hacking needs.
//  Also taking the *rare* step to use underscores rather than
//  camel case for clarity with describing operations.


var 
a = new Q.ComplexNumber( 1,  2 ),
b = new Q.ComplexNumber( 3, -4 ),
a_add_b      = a.add( b ),
a_subtract_b = a.subtract( b ),
a_multiply_b = a.multiply( b )
a_divide_b   = a.divide( b )

console.log( '' )
console.log( 'ğ’‚ =', a.toString() )
console.log( 'ğ’ƒ =', b.toString() )
console.log( '' )
console.log( 'ğ’‚ + ğ’ƒ = ', a_add_b.toString() )
console.log( 'ğ’‚ - ğ’ƒ =', a_subtract_b.toString() )
console.log( 'ğ’‚ Ã— ğ’ƒ =', a_multiply_b.toString() )
console.log( 'ğ’‚ Ã· ğ’ƒ =', a_divide_b.toString() )
console.log( '' )


//  A reminder that ğ’ŠÂ² = -1.

var
i  = new Q.ComplexNumber( 0,  1 ),
ii = i.multiply( i )

console.log( 'ğ’Š  = ', i.toString() )
console.log( 'ğ’ŠÂ² =', ii.toString() )




		</script>
	</body>
</html>